import React, { useState, useEffect, useRef, memo } from 'react';
import { characters, allCards } from './gameData';
import './animations.css';
import './modal.css';
import './App.css';
import { v4 as uuidv4 } from 'uuid';
import MultiplayerLobby from './MultiplayerLobby';
import ChallengeNotificationModal from './ChallengeNotificationModal';

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç, –æ—Ç–æ–±—Ä–∞–∂–∞—é—â–∏–π –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–≤–µ—Ä–ª–µ–π –≤–æ –≤—Ä–µ–º—è –ø–µ—Ä–µ—Ö–æ–¥–∞
function TransitionOverlay() {
  return (
    <div className="transition-overlay">
      <div className="spinner"></div>
    </div>
  );
}

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
function InfoModal({ onAnimationEnd }) {
  const [shouldAnimateOut, setShouldAnimateOut] = useState(false);

  const handleClose = () => {
    setShouldAnimateOut(true);
  };

  useEffect(() => {
    if (shouldAnimateOut) {
      const timer = setTimeout(() => {
        onAnimationEnd(); // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã–≤–∞–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç, –∫–æ–≥–¥–∞ –∞–Ω–∏–º–∞—Ü–∏—è –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è
      }, 300); // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏ –∑–∞–∫—Ä—ã—Ç–∏—è –≤ CSS (–¥–æ–ª–∂–Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å CSS)
      return () => clearTimeout(timer);
    }
  }, [shouldAnimateOut, onAnimationEnd]);

  return (
    <div className={`modal-backdrop ${shouldAnimateOut ? 'modal-fade-out' : 'modal-fade-in'}`}>
      <div className="modal-content">
        <h2>–û Manafall</h2>
        <p>–í–µ—Ä—Å–∏—è: Alpha</p>
        <p>Dante Morrigan üßë‚Äçüíª</p>
        <p>–ú–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è –∫–∞—Ä—Ç–æ—á–Ω–∞—è –∏–≥—Ä–∞, –≤ –∫–æ—Ç–æ—Ä–æ–π –ø–æ–±–µ–∂–¥–∞–µ—Ç —Ç–æ—Ç, –∫—Ç–æ –ª—É—á—à–µ —É–ø—Ä–∞–≤–ª—è–µ—Ç –º–∞–Ω–æ–π –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π. –û—Å–Ω–æ–≤–∞–Ω–∞ –Ω–∞ –ø—Ä–æ—Å—Ç–æ–π –º–µ—Ö–∞–Ω–∏–∫–µ –∏ —Å—Ç–∏–ª—å–Ω–æ–º –¥–∏–∑–∞–π–Ω–µ.</p>
        <button onClick={handleClose} className="modal-close-button">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  );
}

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
function ConfirmationModal({ message, onConfirm, onCancel }) {
  return (
    <div className="modal-backdrop modal-fade-in">
      <div className="modal-content">
        <h2>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</h2>
        <p>{message}</p>
        <div style={{ display: 'flex', justifyContent: 'center', gap: '15px', marginTop: '20px' }}>
          <button onClick={onConfirm} className="button-primary button-hover">
            –î–∞
          </button>
          <button onClick={onCancel} className="modal-close-button">
            –û—Ç–º–µ–Ω–∞
          </button>
        </div>
      </div>
    </div>
  );
}

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç-–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Å–µ—Ç–µ–≤–æ–π –∏–≥—Ä—ã
function MultiplayerPlaceholder({ onBack }) {
  return (
    <div className="game-container placeholder-page modal-fade-in">
      <h2 style={{ fontSize: '3rem', fontWeight: 'bold', color: 'var(--color-primary-light)' }}>
        –°–µ—Ç–µ–≤–∞—è –∏–≥—Ä–∞
      </h2>
      <p style={{ marginTop: '20px', fontSize: '1.2rem' }}>
        –ó–∞–≥–ª—É—à–∫–∞: –≠—Ç–æ—Ç —Ä–µ–∂–∏–º –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.
      </p>
      <div className="loading-spinner"></div>
      <button onClick={onBack} className="link-button" style={{ marginTop: '40px' }}>
        –ù–∞–∑–∞–¥
      </button>
    </div>
  );
}

// --- –ù–û–í–´–ï –ö–û–ú–ü–û–ù–ï–ù–¢–´ –î–õ–Ø –†–ï–ì–ò–°–¢–†–ê–¶–ò–ò –ò –í–•–û–î–ê ---
function AuthModal({ onClose, onLogin, onRegister }) {
  const [isLoginView, setIsLoginView] = useState(true);
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleAuth = (e) => {
    e.preventDefault();
    setError('');

    // –ò–º–∏—Ç–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ localStorage
    const users = JSON.parse(localStorage.getItem('users')) || {};

    if (isLoginView) {
      // –õ–æ–≥–∏–∫–∞ –≤—Ö–æ–¥–∞
      if (users[username] && users[username].password === password) {
        onLogin(username);
      } else {
        setError('–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å.');
      }
    } else {
      // –õ–æ–≥–∏–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
      if (users[username]) {
        setError('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.');
      } else {
        const newUser = {
          username,
          password,
          avatar: 'https://cdn-icons-png.flaticon.com/512/149/149071.png',
          stats: { wins: 0, losses: 0 }
        };
        users[username] = newUser;
        localStorage.setItem('users', JSON.stringify(users)); // <-- –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â—É—é –±–∞–∑—É
        onRegister(username);
      }
    }
  };

  return (
    <div className="modal-backdrop modal-fade-in">
      <div className="modal-content auth-modal">
        <h2>{isLoginView ? '–í—Ö–æ–¥' : '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è'}</h2>
        <form onSubmit={handleAuth}>
          <input
            type="text"
            placeholder="–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            required
          />
          <input
            type="password"
            placeholder="–ü–∞—Ä–æ–ª—å"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
          {error && <p className="auth-error">{error}</p>}
          <button type="submit" className="button-primary">
            {isLoginView ? '–í–æ–π—Ç–∏' : '–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è'}
          </button>
        </form>
        <button
          onClick={() => setIsLoginView(!isLoginView)}
          className="link-button"
        >
          {isLoginView ? '–ù–µ—Ç –∞–∫–∫–∞—É–Ω—Ç–∞? –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è' : '–£–∂–µ –µ—Å—Ç—å –∞–∫–∫–∞—É–Ω—Ç? –í–æ–π—Ç–∏'}
        </button>
        <button onClick={onClose} className="modal-close-button">
          –ó–∞–∫—Ä—ã—Ç—å
        </button>
      </div>
    </div>
  );
}

function ProfileModal({ user, onClose, onLogout }) {
  return (
    <div className="modal-backdrop modal-fade-in">
      <div className="modal-content profile-modal">
        <div className="profile-header">
          <img src={user.avatar} alt="–ê–≤–∞—Ç–∞—Ä" className="profile-avatar" />
          <h2>–ü—Ä–∏–≤–µ—Ç, {user.username}!</h2>
        </div>
        <div className="profile-stats">
          <p>–ü–æ–±–µ–¥—ã: {user.stats.wins}</p>
          <p>–ü–æ—Ä–∞–∂–µ–Ω–∏—è: {user.stats.losses}</p>
        </div>
        <button onClick={onLogout} className="button-primary">
          –í—ã–π—Ç–∏
        </button>
        <button onClick={onClose} className="modal-close-button">
          –ó–∞–∫—Ä—ã—Ç—å
        </button>
      </div>
    </div>
  );
}

// –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
function Landing({ onPlay, onMultiplayer, onOpenInfo, onOpenAuth, onOpenProfile, onLogout, currentUser, isFadingOut, isMuted, onToggleMute, volume, onVolumeChange, animateStep }) {
  return (
    <div className={`game-container landing-page ${isFadingOut ? 'fade-out' : ''}`}>
      <div className="animated-gradient"></div>

      <div className="header-menu">
        {currentUser ? (
          <div className="profile-section" onClick={onOpenProfile}>
            <img src={currentUser.avatar} alt="–ê–≤–∞—Ç–∞—Ä" className="profile-avatar-small" />
            <span className="profile-name">{currentUser.username}</span>
          </div>
        ) : (
          <button onClick={onOpenAuth} className="button-link">–í—Ö–æ–¥ / –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</button>
        )}
      </div>

      <h1 className="game-title" style={{
        opacity: animateStep >= 1 ? 1 : 0,
        transform: animateStep >= 1 ? 'scale(1)' : 'scale(0.8)',
        transition: 'all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
        position: 'relative',
        zIndex: 2,
      }}>
        Manafall
      </h1>

      <p className="game-subtitle" style={{
        opacity: animateStep >= 2 ? 1 : 0,
        transform: animateStep >= 2 ? 'translateY(0)' : 'translateY(20px)',
        transition: 'all 0.6s ease 0.4s',
        position: 'relative',
        zIndex: 2,
      }}>
        –ú–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è –∫–∞—Ä—Ç–æ—á–Ω–∞—è –∏–≥—Ä–∞ —Å –≤—ã–±–æ—Ä–æ–º –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π –∏ –∫—Ä—É—Ç—ã–º–∏ —Å—Ä–∞–∂–µ–Ω–∏—è–º–∏.
      </p>

      <div className="main-menu-buttons" style={{
        opacity: animateStep >= 3 ? 1 : 0,
        transform: animateStep >= 3 ? 'scale(1)' : 'scale(0.9)',
        transition: 'all 0.6s ease 0.8s',
        position: 'relative',
        zIndex: 2,
      }}>
        <button
          onClick={onPlay}
          className="button-primary button-hover"
        >
          –û–¥–∏–Ω–æ—á–Ω–∞—è –∏–≥—Ä–∞
        </button>
        <button
          onClick={onMultiplayer}
          className="button-secondary button-hover"
        >
          –°–µ—Ç–µ–≤–∞—è –∏–≥—Ä–∞
        </button>
      </div>
      
      <div className="utility-buttons">
        <button
          onClick={onOpenInfo}
          className="icon-button"
          title="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"
          style={{
            opacity: animateStep >= 3 ? 1 : 0,
            transition: 'opacity 0.6s ease 0.8s',
            zIndex: 2,
          }}
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="32"
            height="32"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            style={{ verticalAlign: 'middle' }}
          >
            <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73 2.73l.08.15a2 2 0 0 1 0 2l-.25.43a2 2 0 0 1-1.73 1H4a2 2 0 0 0-2 2v.44a2 2 0 0 0 2 2h.18a2 2 0 0 1 1.73 1l.25.43a2 2 0 0 1 0 2l-.08.15a2 2 0 0 0 2.73 2.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-2.73l-.08-.15a2 2 0 0 1 0-2l.25-.43a2 2 0 0 1 1.73-1H20a2 2 0 0 0 2-2v-.44a2 2 0 0 0-2-2h-.18a2 2 0 0 1-1.73-1l-.25-.43a2 2 0 0 1 0-2l.08-.15a2 2 0 0 0-2.73-2.73l-.15.08a2 2 0 0 1-2 0l-.43-.25A2 2 0 0 1 12.22 2z"></path>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </button>
        <div style={{
          display: 'flex', alignItems: 'center', gap: '10px',
          opacity: animateStep >= 3 ? 1 : 0,
          transition: 'opacity 0.6s ease 0.8s',
          zIndex: 2,
        }}>
          <button
            onClick={onToggleMute}
            className="icon-button"
            title={isMuted ? "–í–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É" : "–í—ã–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É"}
          >
            {isMuted ? (
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-volume-x"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="22" x2="16" y1="9" y2="15"/><line x1="16" x2="22" y1="9" y2="15"/></svg>
            ) : (
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
            )}
          </button>
          <input
            type="range"
            min="0"
            max="1"
            step="0.05"
            value={volume}
            onChange={onVolumeChange}
            className="volume-slider"
          />
        </div>
      </div>
    </div>
  );
}

// –ö–∞—Ä—Ç–æ—á–∫–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (–æ–±–µ—Ä–Ω—É—Ç–∞ –≤ React.memo –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏)
const CharacterCard = memo(({ char, selected, onSelect }) => {
  const emoji = char.id === 'warrior' ? '‚öîÔ∏è' : char.id === 'mage' ? '‚ú®' : '';
  return (
    <div
      onClick={() => onSelect(char.id)}
      className={`character-card ${selected ? 'selected' : ''}`}
    >
      <h3>{char.name} {emoji}</h3>
      <p>{char.desc}</p>
    </div>
  );
});

// –ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
function CharacterSelect({ characters, selectedChar, onSelect, onBack, onConfirm, isFadingOut }) {
  return (
    <div className={`game-container character-select-page ${isFadingOut ? 'fade-out' : ''}`}>
      <h2>–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
      <div className="characters-container" style={{
        display: 'flex', gap: 20, flexWrap: 'wrap',
        justifyContent: 'center', width: '100%', maxWidth: 800,
      }}>
        {characters.map(char => (
          <CharacterCard
            key={char.id}
            char={char}
            selected={selectedChar === char.id}
            onSelect={onSelect}
          />
        ))}
      </div>

      <button
        disabled={!selectedChar}
        onClick={onConfirm}
        className="button-primary button-hover"
        style={{
          marginTop: 30,
        }}
      >
        –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å
      </button>

      <button
        onClick={onBack}
        className="link-button"
      >
        –ù–∞–∑–∞–¥
      </button>
    </div>
  );
}

// –ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
function DifficultySelect({ onSelect, onBack, isFadingOut }) {
  const difficulties = [
    { level: '–õ–µ–≥–∫–∏–π', emoji: 'üå±', multiplier: 0.5, desc: '–ò–ò –∏–≥—Ä–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–µ –∫–∞—Ä—Ç—ã.' },
    { level: '–°—Ä–µ–¥–Ω–∏–π', emoji: 'üß†', multiplier: 0.8, desc: '–ò–ò –∏–≥—Ä–∞–µ—Ç —Å–∞–º—ã–µ —Å–∏–ª—å–Ω—ã–µ –∫–∞—Ä—Ç—ã.' },
    { level: '–í—ã—Å–æ–∫–∏–π', emoji: 'üî•', multiplier: 1.0, desc: '–ò–ò –∏—â–µ—Ç –ª—É—á—à—É—é –∞—Ç–∞–∫—É.' },
    { level: '–ú–∞–≥–∏—Å—Ç—Ä', emoji: 'üëë', multiplier: 1.2, desc: '–ò–ò –≤—ã–±–∏—Ä–∞–µ—Ç –∏–¥–µ–∞–ª—å–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é.' },
  ];
  return (
    <div className={`game-container difficulty-select-page ${isFadingOut ? 'fade-out' : ''}`}>
      <h2>–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å</h2>
      <div className="difficulties-container" style={{
        display: 'flex', gap: 20, flexWrap: 'wrap',
        justifyContent: 'center', width: '100%', maxWidth: 800,
      }}>
        {difficulties.map(d => (
          <div
            key={d.level}
            onClick={() => onSelect(d.multiplier)}
            className="character-card button-hover"
          >
            <h3 style={{color: 'var(--color-light-text)'}}>{d.level} {d.emoji}</h3>
            <p style={{color: 'var(--color-light-text)'}}>{d.desc}</p>
          </div>
        ))}
      </div>
      <button
        onClick={onBack}
        className="link-button"
      >
        –ù–∞–∑–∞–¥
      </button>
    </div>
  );
}

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –ø–æ–ª–æ—Å—ã —Å–æ—Å—Ç–æ—è–Ω–∏—è (HP, Mana, Armor) (–æ–±–µ—Ä–Ω—É—Ç –≤ React.memo –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏)
const StatusBar = memo(({ label, current, max, color, isArmor }) => {
  const effectiveMax = max || current;
  const percentage = effectiveMax > 0 ? (current / effectiveMax) * 100 : 0;
  
  // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —à–∫–∞–ª—ã –±—Ä–æ–Ω–∏
  const armorMax = 10; 
  const armorPercentage = isArmor ? Math.min((current / armorMax) * 100, 100) : percentage;

  return (
    <div className="status-bar-container">
      <span className="status-bar-label">{label}: {current}</span>
      <div className="status-bar-bg">
        <div
          className={`status-bar-fill ${isArmor ? 'armor' : ''}`}
          style={{
            width: `${armorPercentage}%`,
            backgroundColor: isArmor ? 'var(--color-armor)' : color
          }}
        />
      </div>
    </div>
  );
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –∫–æ–ª–æ–¥—ã (–∞–ª–≥–æ—Ä–∏—Ç–º –§–∏—à–µ—Ä–∞-–ô–µ—Ç—Å–∞)
function shuffle(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// –£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä—è–º–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è
const takeDamage = (playerState, amount) => {
  let damage = amount;
  let newPlayerState = { ...playerState };
  if (newPlayerState.armor > 0) {
    const blocked = Math.min(newPlayerState.armor, damage);
    newPlayerState.armor -= blocked;
    damage -= blocked;
  }
  newPlayerState.hp -= damage;
  if (newPlayerState.hp < 0) newPlayerState.hp = 0;
  return newPlayerState;
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ —Ä—É–∫–∏
const getMaxHandSize = (currentRound) => {
  if (currentRound <= 3) return 3;
  if (currentRound <= 6) return 5;
  return 6;
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–ª–æ–¥—ã
const createBalancedDeck = (baseCards, totalSize) => {
  const shuffledCards = shuffle(baseCards);
  const deck = [];
  const cardCounts = {};

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞—Ä—Ç—ã
  const addCard = (cardId) => {
    const cardToAdd = allCards.find(c => c.id === cardId);
    if (cardToAdd) {
      deck.push({ ...cardToAdd, uuid: uuidv4() });
      cardCounts[cardId] = (cardCounts[cardId] || 0) + 1;
      return true;
    }
    return false;
  };
  
  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–ª–æ–¥—ã —Å –∑–∞–¥–∞–Ω–Ω—ã–º —Å–æ—Å—Ç–∞–≤–æ–º
  const deckComposition = {
    'attack': 6,
    'defense': 4,
    'utility': 2,
    'heal': 1
  };

  const cardPool = [...shuffledCards];
  const finalDeck = [];

  for (const [type, count] of Object.entries(deckComposition)) {
    const cardsOfType = cardPool.filter(c => c.type === type);
    finalDeck.push(...cardsOfType.slice(0, count));
  }

  // –î–æ–±–∏–≤–∞–µ–º –¥–æ –Ω—É–∂–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
  while (finalDeck.length < totalSize && cardPool.length > 0) {
    finalDeck.push({ ...cardPool.pop(), uuid: uuidv4() });
  }

  return shuffle(finalDeck);
};

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ–±–µ–¥—ã
function VictoryAnimation() {
  const confettiCount = 50;
  const confetti = Array.from({ length: confettiCount }).map((_, i) => {
    const style = {
      left: `${Math.random() * 100}vw`,
      animationDuration: `${Math.random() * 3 + 2}s`,
      animationDelay: `${Math.random() * 1}s`,
      transform: `scale(${Math.random() * 0.5 + 0.5})`,
    };
    return <div key={i} className="confetti" style={style} />;
  });

  return <div className="victory-animation-container">{confetti}</div>;
}

function Game({ playerClass, difficulty, onExit, onWin, onLose, isFadingOut }) {
  const [player, setPlayer] = useState(null);
  const [ai, setAi] = useState(null);
  const [turn, setTurn] = useState('player');
  const [message, setMessage] = useState('');
  const [round, setRound] = useState(1);
  const [showSurrenderModal, setShowSurrenderModal] = useState(false);
  const maxArmor = 10; // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –±—Ä–æ–Ω—é —Ç–µ–ø–µ—Ä—å 10

  // –õ–æ–≥–∏–∫–∞ –∏–≥—Ä—ã
  const playCard = (cardIndex) => {
    if (!player || turn !== 'player') return;
    const card = player.hand[cardIndex];
    if (!card) return;

    if (card.cost > player.mana) {
      setMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã ‚ú®');
      return;
    }

    let newPlayer = { ...player, hand: [...player.hand], deck: [...player.deck] };
    let newAi = { ...ai, hand: [...ai.hand], deck: [...ai.deck] };

    newPlayer.mana -= card.cost;
    newPlayer.hand.splice(cardIndex, 1);

    let actionMessage = '';

    if (card.type === 'attack') {
      if (newAi.reflect > 0) {
        newPlayer = takeDamage(newPlayer, newAi.reflect);
        actionMessage = `–ò–ò –æ—Ç—Ä–∞–∂–∞–µ—Ç ${newAi.reflect} —É—Ä–æ–Ω–∞! `;
      }
      newAi = takeDamage(newAi, card.value);
      actionMessage = `–í—ã –Ω–∞–Ω–µ—Å–ª–∏ ${card.value} —É—Ä–æ–Ω–∞ –ò–ò. üí•`;
    } else if (card.type === 'defense') {
      newPlayer.armor = Math.min(newPlayer.armor + card.value, maxArmor);
      actionMessage = `–í—ã –ø–æ–ª—É—á–∏–ª–∏ ${card.value} –±—Ä–æ–Ω–∏. üõ°Ô∏è`;
    } else if (card.id === 'reflect') {
      newPlayer.reflect = 3;
      actionMessage = '–í—ã –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ —É—Ä–æ–Ω–∞. ‚ú®';
    } else if (card.type === 'heal') {
      newPlayer.hp = Math.min(newPlayer.hp + card.value, newPlayer.maxHp);
      actionMessage = `–í—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ ${card.value} HP. üíñ`;
    } else if (card.id === 'draw_cards') {
      for (let i = 0; i < card.value; i++) {
        const cardToDraw = newPlayer.deck.shift();
        if (cardToDraw) {
          newPlayer.hand.push(cardToDraw);
        }
      }
      actionMessage = `–í—ã –≤–∑—è–ª–∏ ${card.value} –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã. üÉè`;
    } else if (card.id === 'mana_drain') {
      newAi.mana = Math.max(0, newAi.mana - card.value);
      actionMessage = `–í—ã –≤—ã—Ç—è–Ω—É–ª–∏ ${card.value} –º–∞–Ω—ã —É –ò–ò. üåÄ`;
    } else {
      actionMessage = '–ö–∞—Ä—Ç–∞ —Å—ã–≥—Ä–∞–Ω–∞.';
    }

    setPlayer(newPlayer);
    setAi(newAi);
    setMessage(actionMessage);

    setTurn('ai');
    setTimeout(() => setMessage('–•–æ–¥ –ò–ò...'), 1000);
  };

  // –õ–æ–≥–∏–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã
  useEffect(() => {
    // –°–æ–∑–¥–∞–µ–º —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–ª–æ–¥—ã –¥–ª—è –∏–≥—Ä–æ–∫–∞ –∏ –ò–ò
    const pDeck = createBalancedDeck(playerClass.deck, 15);
    const aiClass = characters.find(c => c.id !== playerClass.id) || characters[0];
    const aiDeck = createBalancedDeck(aiClass.deck, 15);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏–≥—Ä—ã —Å –Ω–æ–≤—ã–º–∏ –∫–æ–ª–æ–¥–∞–º–∏
    const p = { name: '–ò–≥—Ä–æ–∫', maxHp: 30, hp: 30, mana: 0, maxMana: 2, armor: 0, deck: pDeck, hand: [], reflect: 0 };
    const aiPlayer = { name: '–ò–ò', maxHp: 30, hp: 30, mana: 0, maxMana: 2, armor: 0, deck: aiDeck, hand: [], reflect: 0 };

    const initialHandSize = getMaxHandSize(1);
    for (let i = 0; i < initialHandSize; i++) {
        const pCard = p.deck.shift();
        if (pCard) p.hand.push(pCard);
        const aiCard = aiPlayer.deck.shift();
        if (aiCard) aiPlayer.hand.push(aiCard);
    }

    p.maxMana = 2;
    p.mana = p.maxMana;
    aiPlayer.maxMana = 2;
    aiPlayer.mana = aiPlayer.maxMana;
    aiPlayer.hp = Math.round(aiPlayer.hp * difficulty);

    setPlayer(p);
    setAi(aiPlayer);
    setTurn('player');
    setMessage('–í–∞—à —Ö–æ–¥ ‚ú®');
    setRound(1);
  }, [playerClass, difficulty]);

  // –õ–æ–≥–∏–∫–∞ —Ö–æ–¥–∞ –ò–ò –∏ –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞
  useEffect(() => {
    if (turn === 'ai' && ai && player) {
      // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ö–æ–¥–∞ –ò–ò
      const aiTurnTimeout = setTimeout(() => {
        let newAi = { ...ai, hand: [...ai.hand], deck: [...ai.deck] };
        let newPlayer = { ...player, hand: [...player.hand], deck: [...player.deck] };

        // –õ–æ–≥–∏–∫–∞ –Ω–∞—á–∞–ª–∞ —Ö–æ–¥–∞ –¥–ª—è –ò–ò
        newAi.maxMana = Math.min(newAi.maxMana + 1, 10);
        newAi.mana = newAi.maxMana;
        
        const aiMaxHandSize = getMaxHandSize(round);
        while(newAi.hand.length < aiMaxHandSize && newAi.deck.length > 0) {
          const cardToDraw = newAi.deck.shift();
          if (cardToDraw) {
            newAi.hand.push(cardToDraw);
          }
        }
        newAi.reflect = 0;

        const playableCards = newAi.hand.filter(c => c.cost <= newAi.mana);
        if (playableCards.length === 0) {
          setMessage('–ò–ò –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥ (–Ω–µ—Ç –º–∞–Ω—ã –∏–ª–∏ –∫–∞—Ä—Ç)');
          setTurn('player');
          return;
        }

        let card;
        // –õ–æ–≥–∏–∫–∞ –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
        if (difficulty <= 0.5) { // –õ–µ–≥–∫–∏–π
          const randomCardIndex = Math.floor(Math.random() * playableCards.length);
          card = playableCards[randomCardIndex];
        } else if (difficulty <= 0.8) { // –°—Ä–µ–¥–Ω–∏–π
          card = playableCards.sort((a, b) => b.cost - a.cost)[0];
        } else if (difficulty <= 1.0) { // –í—ã—Å–æ–∫–∏–π
          const attackCards = playableCards.filter(c => c.type === 'attack');
          card = attackCards.sort((a, b) => b.value - a.value)[0] || playableCards.sort((a, b) => b.cost - a.cost)[0];
        } else { // –ú–∞–≥–∏—Å—Ç—Ä (1.2)
          const attackCards = playableCards.filter(c => c.type === 'attack');
          const defenseCards = playableCards.filter(c => c.type === 'defense');
          if (player.hp <= 10 && attackCards.length > 0) {
            card = attackCards.sort((a, b) => b.value - a.value)[0];
          } else if (newAi.hp <= 10 && defenseCards.length > 0) {
            card = defenseCards.sort((a, b) => b.value - a.value)[0];
          } else {
            card = playableCards.sort((a, b) => b.cost - a.cost)[0];
          }
        }

        if (!card) {
            // –ï—Å–ª–∏ –Ω–µ—Ç –∏–≥—Ä–∞–±–µ–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã, –ò–ò –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥
            setMessage('–ò–ò –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥ (–Ω–µ—Ç –º–∞–Ω—ã –∏–ª–∏ –∫–∞—Ä—Ç)');
        } else {
          const cardIndex = newAi.hand.findIndex(c => c.uuid === card.uuid);
          newAi.mana -= card.cost;
          newAi.hand.splice(cardIndex, 1);

          let actionMessage = '';

          if (card.type === 'attack') {
            if (newPlayer.reflect > 0) {
              newAi = takeDamage(newAi, newPlayer.reflect);
              actionMessage = `–í—ã –æ—Ç—Ä–∞–∂–∞–µ—Ç–µ ${newPlayer.reflect} —É—Ä–æ–Ω–∞! `;
            }
            newPlayer = takeDamage(newPlayer, card.value);
            actionMessage = `–ò–ò –Ω–∞–Ω–æ—Å–∏—Ç –≤–∞–º ${card.value} —É—Ä–æ–Ω–∞. üí•`;
          } else if (card.type === 'defense') {
            newAi.armor = Math.min(newAi.armor + card.value, maxArmor);
            actionMessage = `–ò–ò –ø–æ–ª—É—á–∞–µ—Ç ${card.value} –±—Ä–æ–Ω–∏. üõ°Ô∏è`;
          } else if (card.id === 'reflect') {
            newAi.reflect = 3;
            actionMessage = '–ò–ò –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ —É—Ä–æ–Ω–∞. ‚ú®';
          } else if (card.type === 'heal') {
            newAi.hp = Math.min(newAi.hp + card.value, newAi.maxHp);
            actionMessage = `–ò–ò –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª ${card.value} HP. üíñ`;
          } else if (card.id === 'draw_cards') {
            for (let i = 0; i < card.value; i++) {
              const cardToDraw = newAi.deck.shift();
              if (cardToDraw) {
                newAi.hand.push(cardToDraw);
              }
            }
            actionMessage = `–ò–ò –≤–∑—è–ª ${card.value} –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã. üÉè`;
          } else if (card.id === 'mana_drain') {
            newPlayer.mana = Math.max(0, newPlayer.mana - card.value);
            actionMessage = `–ò–ò –≤—ã—Ç—è–Ω—É–ª ${card.value} –º–∞–Ω—ã —É –≤–∞—Å. üåÄ`;
          } else {
            actionMessage = '–ò–ò —Å—ã–≥—Ä–∞–ª –∫–∞—Ä—Ç—É.';
          }
          setMessage(actionMessage);
        }

        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ö–æ–¥–∞ –ò–ò –∏ –Ω–∞—á–∞–ª–æ —Ö–æ–¥–∞ –∏–≥—Ä–æ–∫–∞
        setTimeout(() => {
          const nextRound = round + 1;
          const playerMaxHandSize = getMaxHandSize(nextRound);
          
          newPlayer.maxMana = Math.min(newPlayer.maxMana + 1, 10);
          newPlayer.mana = newPlayer.maxMana;
          while(newPlayer.hand.length < playerMaxHandSize && newPlayer.deck.length > 0) {
            const cardToDraw = newPlayer.deck.shift();
            if (cardToDraw) {
              newPlayer.hand.push(cardToDraw);
            }
          }
          newPlayer.reflect = 0;

          const playerHasPlayableCards = newPlayer.hand.some(c => c.cost <= newPlayer.mana);
          if (!playerHasPlayableCards && newPlayer.deck.length === 0) {
            setMessage('–£ –≤–∞—Å –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –∫–∞—Ä—Ç—ã, –∏ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥. –í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏! üòû');
            setPlayer({ ...newPlayer, hp: 0 });
            return;
          }

          setPlayer(newPlayer);
          setAi(newAi);
          setTurn('player');
          setRound(nextRound);
          setMessage('–í–∞—à —Ö–æ–¥ ‚ú®');
        }, 1500); // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ö–æ–¥–∞ –∏–≥—Ä–æ–∫–∞
      }, 1000); // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ö–æ–¥–∞ –ò–ò

      return () => clearTimeout(aiTurnTimeout);
    }
  }, [turn, ai, player, difficulty, round, maxArmor]);

  const handleSurrender = () => {
    setPlayer(prev => ({ ...prev, hp: 0 }));
    setShowSurrenderModal(false);
  };

  const handleCancelSurrender = () => {
    setShowSurrenderModal(false);
  };

  useEffect(() => {
    if (player && player.hp <= 0) {
      onLose();
    } else if (ai && ai.hp <= 0) {
      onWin();
    }
  }, [player, ai, onWin, onLose]);

  if (!player || !ai) {
    return (
      <div className={`game-container game-page ${isFadingOut ? 'fade-out' : ''}`}>
        <h2>–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã...</h2>
      </div>
    );
  }

  return (
    <div className={`game-container game-page ${isFadingOut ? 'fade-out' : ''}`}>
      {showSurrenderModal && (
        <ConfirmationModal
          message="–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–∞—Ç—å—Å—è? –≠—Ç–æ –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ –ø–æ—Ä–∞–∂–µ–Ω–∏—é."
          onConfirm={handleSurrender}
          onCancel={handleCancelSurrender}
        />
      )}

      {player.hp <= 0 ? (
        <div className="victory-defeat-screen">
          <h1>–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ üòû</h1>
          <button onClick={onExit} className="button-primary button-hover">
            –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
          </button>
        </div>
      ) : ai.hp <= 0 ? (
        <div className="victory-defeat-screen victory-banner">
          <VictoryAnimation />
          <h1>–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏! üéâ</h1>
          <button onClick={onExit} className="button-primary button-hover">
            –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞
          </button>
        </div>
      ) : (
        <>
          <button onClick={() => setShowSurrenderModal(true)} className="surrender-button-styled">
            –°–¥–∞—Ç—å—Å—è üè≥Ô∏è
          </button>

          <div className="game-info-container">
            <h2>–†–∞—É–Ω–¥: {round}</h2>
            <div className="game-players-container">
              <div className="player-box">
                <h3>–ò–≥—Ä–æ–∫</h3>
                <StatusBar label="HP" current={player.hp} max={player.maxHp} color="var(--color-error)" />
                <StatusBar label="–ú–∞–Ω–∞" current={player.mana} max={player.maxMana} color="var(--color-mana)" />
                <StatusBar label="–ë—Ä–æ–Ω—è" current={player.armor} max={maxArmor} color="var(--color-armor)" isArmor={true} />
              </div>

              <div className="player-box-ai">
                <h3>–ò–ò</h3>
                <StatusBar label="HP" current={ai.hp} max={ai.maxHp} color="var(--color-error)" />
                <StatusBar label="–ú–∞–Ω–∞" current={ai.mana} max={ai.maxMana} color="var(--color-mana)" />
                <StatusBar label="–ë—Ä–æ–Ω—è" current={ai.armor} max={maxArmor} color="var(--color-armor)" isArmor={true} />
                <p>–ö–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ: {ai.deck.length}</p>
              </div>
            </div>

            <p className="game-message">{message}</p>
          </div>

          <div className="player-hand">
            {player.hand.map((card, i) => {
              const isPlayable = player.mana >= card.cost && turn === 'player';
              return (
                <div
                  key={card.uuid}
                  onClick={() => playCard(i)}
                  className={`hand-card ${isPlayable ? 'playable' : ''}`}
                  style={{
                    pointerEvents: turn === 'player' ? 'auto' : 'none',
                  }}
                  title={`${card.name}: ${card.description}`}
                >
                  <span className="card-cost">{card.cost}</span>
                  <h4>{card.name}</h4>
                  <p>{card.description}</p>
                </div>
              );
            })}
          </div>
        </>
      )}
    </div>
  );
}

export default function App() {
  const [stage, setStage] = useState('landing');
  const [selectedChar, setSelectedChar] = useState(null);
  const [difficulty, setDifficulty] = useState(1);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [volume, setVolume] = useState(0.5);
  const [isInfoModalVisible, setIsInfoModalVisible] = useState(false);
  const [isAuthModalVisible, setIsAuthModalVisible] = useState(false);
  const [isProfileModalVisible, setIsProfileModalVisible] = useState(false);
  const [currentUser, setCurrentUser] = useState(null);
  const [opponent, setOpponent] = useState(null);
  const [pendingChallenge, setPendingChallenge] = useState(null);

  const TRANSITION_DURATION = 500;
  const audioRef = useRef(null);

  // –°–ø–∏—Å–æ–∫ –º—É–∑—ã–∫–∞–ª—å–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤
  const musicTracks = ['/music1.mp3', '/music2.mp3'];
  const [currentTrack, setCurrentTrack] = useState(musicTracks[Math.floor(Math.random() * musicTracks.length)]);

  useEffect(() => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ localStorage –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    const storedUser = JSON.parse(localStorage.getItem('currentUser'));
    if (storedUser) {
      setCurrentUser(storedUser);
    }
  }, []);

  useEffect(() => {
    if (!audioRef.current) {
      audioRef.current = new Audio(currentTrack); // <-- –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —Ç—Ä–µ–∫
      audioRef.current.loop = true;
      audioRef.current.volume = volume;
      audioRef.current.muted = isMuted;
    }
  }, [currentTrack]); // <-- –î–æ–±–∞–≤–ª—è–µ–º currentTrack –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

  useEffect(() => {
    if (audioRef.current) {
      audioRef.current.volume = volume;
    }
  }, [volume]);

  useEffect(() => {
    if (audioRef.current) {
      audioRef.current.muted = isMuted;
    }
  }, [isMuted]);

  // –≠—Ñ—Ñ–µ–∫—Ç –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—ã–∑–æ–≤–∞
  useEffect(() => {
    if (currentUser && stage === 'multiplayerLobby') {
      const interval = setInterval(() => {
        const challenges = JSON.parse(localStorage.getItem('pendingChallenges')) || {};
        if (challenges[currentUser.username]) {
          setPendingChallenge(challenges[currentUser.username]);
        }
      }, 500); // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑ –≤ –ø–æ–ª—Å–µ–∫—É–Ω–¥—ã
      return () => clearInterval(interval);
    }
  }, [currentUser, stage]);

  const handleVolumeChange = (e) => {
    setVolume(parseFloat(e.target.value));
  };

  const handleToggleMute = () => {
    setIsMuted(!isMuted);
  };

  const handleStageChange = (newStage, callback = () => {}) => {
    setIsTransitioning(true);
    setTimeout(() => {
      setStage(newStage);
      setIsTransitioning(false);
      callback();
    }, TRANSITION_DURATION);
  };

  const handlePlay = async () => {
    if (audioRef.current) {
      try {
        await audioRef.current.play();
      } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–∏ –º—É–∑—ã–∫–∏:", error);
      }
    }
    setSelectedChar(null);
    handleStageChange('characterSelect');
  };

  const handleOpenMultiplayer = () => {
    if (!currentUser) {
      setIsAuthModalVisible(true);
    } else {
      setOpponent(null);
      handleStageChange('multiplayerLobby');
    }
  };

  const handleChallengeSent = (opponentUsername) => {
    const challenges = JSON.parse(localStorage.getItem('pendingChallenges')) || {};
    challenges[opponentUsername] = { from: currentUser.username, status: 'pending' };
    localStorage.setItem('pendingChallenges', JSON.stringify(challenges));
    setOpponent(opponentUsername);
    console.log(`–í—ã–∑–æ–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏–≥—Ä–æ–∫—É ${opponentUsername}`);
  };

  const handleAcceptChallenge = () => {
    const challenger = pendingChallenge.from;
    setOpponent(challenger);
    const challenges = JSON.parse(localStorage.getItem('pendingChallenges')) || {};
    delete challenges[currentUser.username];
    localStorage.setItem('pendingChallenges', JSON.stringify(challenges));
    setPendingChallenge(null);
    handleStageChange('characterSelect');
  };

  const handleDeclineChallenge = () => {
    const challenges = JSON.parse(localStorage.getItem('pendingChallenges')) || {};
    delete challenges[currentUser.username];
    localStorage.setItem('pendingChallenges', JSON.stringify(challenges));
    setPendingChallenge(null);
  };
  
  const handleExitGame = () => {
    setSelectedChar(null);
    setDifficulty(1);
    setOpponent(null);
    handleStageChange('landing');
  };

  const handleWin = () => {
    console.log("–ü–æ–±–µ–¥–∞!");
  };
  
  const handleLose = () => {
    console.log("–ü–æ—Ä–∞–∂–µ–Ω–∏–µ.");
  };

  // –õ–æ–≥–∏–∫–∞ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω
  const handleOpenInfoModal = () => setIsInfoModalVisible(true);
  const handleCloseInfoModal = () => setIsInfoModalVisible(false);
  const handleOpenAuthModal = () => setIsAuthModalVisible(true);
  const handleCloseAuthModal = () => setIsAuthModalVisible(false);
  const handleOpenProfileModal = () => setIsProfileModalVisible(true);
  const handleCloseProfileModal = () => setIsProfileModalVisible(false);

  const handleLogin = (username) => {
    const users = JSON.parse(localStorage.getItem('users')) || {};
    const user = users[username];
    setCurrentUser(user);
    localStorage.setItem('currentUser', JSON.stringify(user));
    setIsAuthModalVisible(false);
  };

  const handleLogout = () => {
    setCurrentUser(null);
    localStorage.removeItem('currentUser');
    setIsProfileModalVisible(false);
  };

  const handleConfirmCharacter = () => {
    if (!opponent) {
      handleStageChange('difficultySelect');
    } else {
      // –≠—Ç–æ –∑–∞–≥–ª—É—à–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.
      // –í —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ –∑–¥–µ—Å—å –ø—Ä–æ–∏–∑–æ—à–ª–∞ –±—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–º.
      handleStageChange('game');
    }
  };

  const playerClass = selectedChar ? characters.find(c => c.id === selectedChar) : null;

  return (
    <div className="app">
      {isTransitioning && <TransitionOverlay />}
      
      {stage === 'landing' && (
        <Landing
          onPlay={handlePlay}
          onMultiplayer={handleOpenMultiplayer}
          onOpenInfo={handleOpenInfoModal}
          onOpenAuth={handleOpenAuthModal}
          onOpenProfile={handleOpenProfileModal}
          onLogout={handleLogout}
          currentUser={currentUser}
          isFadingOut={isTransitioning}
          isMuted={isMuted}
          onToggleMute={handleToggleMute}
          volume={volume}
          onVolumeChange={handleVolumeChange}
          animateStep={stage === 'landing' ? 3 : 0}
        />
      )}

      {stage === 'characterSelect' && (
        <CharacterSelect
          characters={characters}
          selectedChar={selectedChar}
          onSelect={setSelectedChar}
          onBack={() => handleStageChange(opponent ? 'multiplayerLobby' : 'landing')}
          onConfirm={handleConfirmCharacter}
          isFadingOut={isTransitioning}
        />
      )}
      
      {stage === 'difficultySelect' && (
        <DifficultySelect
          onSelect={(mult) => {
            setDifficulty(mult);
            handleStageChange('game');
          }}
          onBack={() => handleStageChange('characterSelect')}
          isFadingOut={isTransitioning}
        />
      )}

      {stage === 'multiplayerLobby' && currentUser && (
        <MultiplayerLobby
          onBack={() => handleStageChange('landing')}
          currentUser={currentUser}
          onChallengeSent={handleChallengeSent}
          isChallengingOpponent={!!opponent}
        />
      )}

      {stage === 'game' && playerClass && (
        <Game
          playerClass={playerClass}
          difficulty={difficulty}
          onExit={handleExitGame}
          onWin={handleWin}
          onLose={handleLose}
          isFadingOut={isTransitioning}
        />
      )}

      {isInfoModalVisible && (
        <InfoModal onAnimationEnd={handleCloseInfoModal} />
      )}
      
      {isAuthModalVisible && (
        <AuthModal
          onClose={handleCloseAuthModal}
          onLogin={handleLogin}
          onRegister={handleLogin}
        />
      )}

      {isProfileModalVisible && currentUser && (
        <ProfileModal
          user={currentUser}
          onClose={handleCloseProfileModal}
          onLogout={handleLogout}
        />
      )}

      {pendingChallenge && (
        <ChallengeNotificationModal
          challenger={pendingChallenge.from}
          onAccept={handleAcceptChallenge}
          onDecline={handleDeclineChallenge}
        />
      )}
    </div>
  );
}